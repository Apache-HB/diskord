package com.serebit.strife.entities

import com.serebit.strife.BotClient
import com.serebit.strife.internal.entitydata.GuildEmojiData
import com.serebit.strife.internal.network.Cdn
import com.serebit.strife.internal.network.ImageFormat
import com.serebit.strife.internal.packets.PartialEmojiPacket
import io.ktor.http.encodeURLQueryComponent

/** A small digital image or icon used to express an idea emotion, etc. */
sealed class Emoji {
    /** How the emoji should be presented in the request body. */
    internal abstract val requestData: String
    /** How the emoji should be presented in the URI. */
    internal abstract val uriData: String
}

/** A user-created Emoji which is housed in a [Guild]. */
class GuildEmoji internal constructor(private val data: GuildEmojiData) : Emoji(), Entity {

    override val requestData = data.id.toString()
    override val uriData = "${data.name}:${data.id}"

    override val id: Long = data.id
    override val context: BotClient = data.context
    /** The name of the [GuildEmoji]. This is used to type the emoji between semi-colons like `:this:` */
    val name: String get() = data.name
    /** The [User] who created this [GuildEmoji]. */
    val creator: User? get() = data.creator?.lazyEntity
    /** The guild roles that are allowed to use this emoji. I think. Discord docs aren't very specific. */
    val whitelistedRoles: List<GuildRole> get() = data.roles.map { it.lazyEntity }
    /** Whether or not this emoji is an animated GIF. */
    val isAnimated: Boolean = data.isAnimated
    /** Whether or not this emoji is managed by an external service, such as a Discord bot. */
    val isManaged: Boolean get() = data.isManaged

    /** Get this [GuildEmoji] as a standard Mention (`<name:ID>`). */
    val asMention: String get() = "<${if (isAnimated) "a:" else ""}$name:$id>"

    /** The URL which leads to the full-sized image. */
    val url: String = Cdn.CustomEmoji(id, if (isAnimated) ImageFormat.Gif else ImageFormat.Png).toString()

    /** Get this [GuildEmoji] as a [standard Mention][asMention] (``<name:ID>``). */
    override fun toString(): String = asMention
}

/**
 * A user-created [Emoji] which the current client cannot use (i.e. the bot is not a member of the [ForeignGuildEmoji]'s
 * housing [Guild]).
 */
data class ForeignGuildEmoji internal constructor(
    override val context: BotClient,
    override val id: Long,
    /** The name by which this emoji can be mentioned. */
    val name: String
) : Emoji(), Entity {
    override val requestData = id.toString()
    override val uriData = "name:$id"

    /** Get this [GuildEmoji] as a standard Mention (``<name:ID>``). */
    val asMention: String = "<:$name:$id>"

    /** Get this [GuildEmoji] as a standard Mention (``<name:ID>``). */
    override fun toString(): String = asMention
}

/**
 * A Standard Unicode [Emoji] represented in [unicode] characters. If the emoji supports a [SkinTone], [tone] property
 * can be set.
 *
 * @property unicode The unicode character(s) corresponding to this emoji.
 * @property tone The skin tone corresponding to this emoji, or null if it has no skin tone.
 */
sealed class UnicodeEmoji(
    val unicode: String,
    val tone: SkinTone? = null
) : Emoji() {
    /** The emoji's [unicode] combined with its [tone]'s unicode, if any. */
    val combinedUnicode: String = tone?.let { unicode + it.unicode } ?: unicode

    override val requestData = combinedUnicode
    override val uriData = combinedUnicode.encodeURLQueryComponent()

    // REPLACEMENT_MARKER

    /** Get this [UnicodeEmoji] as [String] (aka [combinedUnicode]). */
    override fun toString(): String = combinedUnicode

    /** Check if [other] is the same as this [UnicodeEmoji]. */
    override fun equals(other: Any?): Boolean = other.toString() == toString()

    companion object {
        /** A list of 0-10 emojis. */
        val numbers: List<UnicodeEmoji> = listOf(Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Nine, KeycapTen)

        /** Returns given [Int] as a [List] of [UnicodeEmoji]s */
        fun fromInt(num: Int): List<UnicodeEmoji> = num.toString().map { numbers[it.toString().toInt()] }
    }
}

/** Returns [List] of [UnicodeEmoji]s as [String] */
val List<UnicodeEmoji>.asString get() = joinToString("") { it.toString() }

/**
 * An enum containing a list of supported skin tones. Can be used in a [UnicodeEmoji]'s constructor if it supports
 * skin tones.
 *
 * @property unicode The unicode representation of this skin tone.
 */
enum class SkinTone(val unicode: String) {
    /** The lightest skin tone, represented in Discord shortcode as `:skin-tone-1:`. */
    LIGHT("\ud83c\udffb"),
    /** A medium-light skin tone, represented in Discord shortcode as `:skin-tone-2:`. */
    MEDIUM_LIGHT("\ud83c\udffc"),
    /** A medium skin tone, represented in Discord shortcode as `:skin-tone-3:`. */
    MEDIUM("\ud83c\udffd"),
    /** A medium-dark skin tone, represented in Discord shortcode as `:skin-tone-4:`. */
    MEDIUM_DARK("\ud83c\udffe"),
    /** The darkest skin tone, represented in Discord shortcode as `:skin-tone-5:`. */
    DARK("\ud83c\udfff")
}

/** Converts a [PartialEmojiPacket] to an [Emoji]. */
internal fun PartialEmojiPacket.toEmoji(context: BotClient): Emoji =
    id?.let { ForeignGuildEmoji(context, id, name) } ?: UnicodeEmoji.fromUnicode(name)
