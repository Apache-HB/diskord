package com.serebit.strife.entities

import com.serebit.strife.BotClient
import com.serebit.strife.internal.entitydata.GuildEmojiData
import com.serebit.strife.internal.network.Cdn
import com.serebit.strife.internal.network.ImageFormat
import com.serebit.strife.internal.packets.PartialEmojiPacket
import io.ktor.http.encodeURLQueryComponent

/** A small digital image or icon used to express an idea emotion, etc. */
sealed class Emoji {
    /** How the emoji should be presented in the request body. */
    internal abstract suspend fun getRequestData(): String

    /** How the emoji should be presented in the URI. */
    internal abstract suspend fun uriData(): String
}

/** A user-created Emoji which is housed in a [Guild]. */
class GuildEmoji internal constructor(override val id: Long, val guildID: Long, override val context: BotClient) :
    Emoji(), Entity, Mentionable {

    private suspend fun getData() = context.obtainGuildEmojiData(id, guildID)
        ?: throw IllegalStateException("Attempted to get data for a nonexistent emoji with ID $id")

    override suspend fun getRequestData() = getData().id.toString()
    override suspend fun uriData() = "${getData().name}:${getData().id}"

    /** The name of the [GuildEmoji]. This is used to type the emoji between semi-colons like `:this:` */
    suspend fun getName(): String = getData().name

    /** The [User] who created this [GuildEmoji]. */
    suspend fun getCreator(): User? = getData().creator?.lazyEntity

    /** The guild roles that are allowed to use this emoji. I think. Discord docs aren't very specific. */
    suspend fun getWhitelistedRoles(): List<GuildRole> = getData().roles.map { it.lazyEntity }

    /** Whether or not this emoji is an animated GIF. */
    suspend fun isAnimated(): Boolean = getData().isAnimated

    /** Whether or not this emoji is managed by an external service, such as a Discord bot. */
    suspend fun isManaged(): Boolean = getData().isManaged

    /** Get this [GuildEmoji] as a standard Mention (`<name:ID>`). */
    override suspend fun asMention(): String = "<${if (isAnimated()) "a:" else ""}${getName()}:$id>"

    /** The URL which leads to the full-sized image. */
    suspend fun getUrl(): String =
        Cdn.CustomEmoji(id, if (isAnimated()) ImageFormat.Gif else ImageFormat.Png).toString()
}

/**
 * A user-created [Emoji] which the current client cannot use (i.e. the bot is not a member of the [ForeignGuildEmoji]'s
 * housing [Guild]).
 */
data class ForeignGuildEmoji internal constructor(
    override val context: BotClient,
    override val id: Long,
    /** The name by which this emoji can be mentioned. */
    val name: String
) : Emoji(), Entity {
    override suspend fun getRequestData() = id.toString()
    override suspend fun uriData() = "name:$id"

    /** Get this [GuildEmoji] as a standard Mention (``<name:ID>``). */
    val asMention: String = "<:$name:$id>"

    /** Get this [GuildEmoji] as a standard Mention (``<name:ID>``). */
    override fun toString(): String = asMention
}

/**
 * A Standard Unicode [Emoji] represented in [unicode] characters.
 *
 * @property unicode The unicode character(s) corresponding to this emoji.
 */
sealed class UnicodeEmoji(val unicode: String) : Emoji() {
    override suspend fun getRequestData() = unicode
    override suspend fun uriData() = unicode.encodeURLQueryComponent()

    class Invariant internal constructor(unicode: String) : UnicodeEmoji(unicode)
    class VariantSkinTone internal constructor(val baseUnicode: String, val skinTone: SkinTone?) :
        UnicodeEmoji(skinTone?.let { baseUnicode + it.unicode } ?: baseUnicode) {

        val noTone: VariantSkinTone get() = VariantSkinTone(baseUnicode, null)
        val lightest: VariantSkinTone get() = VariantSkinTone(baseUnicode, SkinTone.LIGHTEST)
        val light: VariantSkinTone get() = VariantSkinTone(baseUnicode, SkinTone.LIGHT)
        val medium: VariantSkinTone get() = VariantSkinTone(baseUnicode, SkinTone.MEDIUM)
        val dark: VariantSkinTone get() = VariantSkinTone(baseUnicode, SkinTone.DARK)
        val darkest: VariantSkinTone get() = VariantSkinTone(baseUnicode, SkinTone.DARKEST)

        fun withTone(skinTone: SkinTone?): VariantSkinTone = VariantSkinTone(baseUnicode, skinTone)
    }

    /** Get this [UnicodeEmoji] as [String] (aka [unicode]). */
    override fun toString(): String = unicode

    /** Check if [other] is the same as this [UnicodeEmoji]. */
    override fun equals(other: Any?): Boolean = other.toString() == toString()

    companion object {

        // REPLACEMENT_MARKER

        /** A list of 0-10 emojis. */
        val numbers: List<UnicodeEmoji> = listOf(Zero, One, Two, Three, Four, Five, Six, Seven, Eight, Nine, KeycapTen)

        /** Returns given [Int] as a [List] of [UnicodeEmoji]s */
        fun fromInt(num: Int): List<UnicodeEmoji> = num.toString().map { numbers[it.toString().toInt()] }
    }
}

/** Returns [List] of [UnicodeEmoji]s as [String] */
val List<UnicodeEmoji>.asString get() = joinToString("") { it.toString() }

/**
 * An enum containing a list of supported skin tones. Can be used in a [UnicodeEmoji]'s constructor if it supports
 * skin tones.
 *
 * @property unicode The unicode representation of this skin tone.
 */
enum class SkinTone(val unicode: String) {
    /** The lightest skin tone, represented in Discord shortcode as `:skin-tone-1:`. */
    LIGHTEST("\ud83c\udffb"),
    /** A medium-light skin tone, represented in Discord shortcode as `:skin-tone-2:`. */
    LIGHT("\ud83c\udffc"),
    /** A medium skin tone, represented in Discord shortcode as `:skin-tone-3:`. */
    MEDIUM("\ud83c\udffd"),
    /** A medium-dark skin tone, represented in Discord shortcode as `:skin-tone-4:`. */
    DARK("\ud83c\udffe"),
    /** The darkest skin tone, represented in Discord shortcode as `:skin-tone-5:`. */
    DARKEST("\ud83c\udfff")
}

/** Converts a [PartialEmojiPacket] to an [Emoji]. */
internal fun PartialEmojiPacket.toEmoji(context: BotClient): Emoji =
    id?.let { ForeignGuildEmoji(context, id, name) } ?: UnicodeEmoji.fromUnicode(name)
